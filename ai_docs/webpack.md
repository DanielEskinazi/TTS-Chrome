TITLE: Webpack Configuration JavaScript
DESCRIPTION: This JavaScript snippet shows the webpack configuration file used to bundle the CoffeeScript code. It defines the entry point, output settings, and source map configurations to generate various types of source maps.
SOURCE: https://github.com/webpack/webpack/blob/main/examples/source-map/template.md#_snippet_1

LANGUAGE: javascript
CODE:

```
_{{webpack.config.js}}_
```

---

TITLE: Webpack Configuration with Module Federation (mfe-c)
DESCRIPTION: This webpack configuration defines the 'mfe-c' module. It configures the entry point (empty), output, module rules, optimization settings, and plugins. The ModuleFederationPlugin exposes two modules ('./Component' and './Component2') and defines shared modules ('lodash/', 'date-fns', and 'react'). The 'react' shared module has 'import: false' which indicates that it relies on a shared version provided by another module at runtime.
SOURCE: https://github.com/webpack/webpack/blob/main/examples/module-federation/README.md#_snippet_2

LANGUAGE: javascript
CODE:

```
{
		name: "mfe-c",
		mode: env,
		entry: {},
		output: {
			filename: "[name].js",
			path: path.resolve(__dirname, "dist/ccc"),
			publicPath: "dist/ccc/",
			uniqueName: "module-federation-ccc"
		},
		module: { rules },
		optimization,
		plugins: [
			new ModuleFederationPlugin({
				name: "mfeCCC",

				exposes: {
					"./Component": "./src-c/Component",
					"./Component2": "./src-c/LazyComponent"
				},

				shared: [
					// All (used) requests within lodash are shared.
					"lodash/",
					"date-fns",
					{
						react: {
							// Do not load our own version.
							// There must be a valid shared module available at runtime.
							// This improves build time as this module doesn't need to be compiled,
							// but it opts-out of possible fallbacks and runtime version upgrade.
							import: false,
							singleton: true
						}
					}
				]
			})
		],
		stats
	}
```

---

TITLE: Webpack Configuration Example
DESCRIPTION: This snippet represents a webpack configuration file (webpack.config.js). It defines how webpack should bundle the project's JavaScript files, including entry points, output settings, and potentially loaders and plugins. The specific content of the configuration is not provided, but it's crucial for understanding the bundling process.
SOURCE: https://github.com/webpack/webpack/blob/main/examples/harmony-library/template.md#_snippet_0

LANGUAGE: javascript
CODE:

```
_{{webpack.config.js}}_
```

---

TITLE: dist/file_js.output.js Asynchronously Loaded Module
DESCRIPTION: This is the dynamically loaded module generated by the bundle loader. It contains the code from 'file.js' and is loaded on demand.
SOURCE: https://github.com/webpack/webpack/blob/main/examples/code-splitting-bundle-loader/template.md#_snippet_3

LANGUAGE: JavaScript
CODE:

```
_{{dist/file_js.output.js}}_
```

---

TITLE: Initializing DB Connection with Top-Level Await (JavaScript)
DESCRIPTION: This code snippet demonstrates using top-level await to connect to a database before the module is usable. It defines an async function `connectToDB` that simulates a database connection with a delay and then uses `await` outside of a function to establish the connection when the module is loaded. It exports functions for making a db call and closing the db connection.
SOURCE: https://github.com/webpack/webpack/blob/main/examples/top-level-await/README.md#_snippet_0

LANGUAGE: javascript
CODE:

```
const connectToDB = async url => {
	await new Promise(r => setTimeout(r, 1000));
};

// This is a top-level-await
await connectToDB("my-sql://example.com");

export const dbCall = async data => {
	// This is a normal await, because it's in an async function
	await new Promise(r => setTimeout(r, 100));
	return "fake data";
};

export const close = () => {
	console.log("closes the DB connection");
};
```

---

TITLE: Webpack Runtime - Chunk Loading
DESCRIPTION: This snippet manages asynchronous chunk loading in Webpack. It defines `__webpack_require__.e` for ensuring a chunk is loaded. The `__webpack_require__.f` object is used to store chunk-specific loading functions, and `Promise.all` is used to manage multiple asynchronous loading operations. It relies on `__webpack_require__.f` to provide the actual chunk loading logic.
SOURCE: https://github.com/webpack/webpack/blob/main/examples/code-splitting-native-import-context/README.md#_snippet_5

LANGUAGE: javascript
CODE:

```
/******/ 	/* webpack/runtime/ensure chunk */
/******/ 	(() => {
/******/ 		__webpack_require__.f = {};
/******/ 		// This file contains only the entry chunk.
/******/ 		// The chunk loading function for additional chunks
/******/ 		__webpack_require__.e = (chunkId) => {
/******/ 			return Promise.all(Object.keys(__webpack_require__.f).reduce((promises, key) => {
/******/ 				__webpack_require__.f[key](chunkId, promises);
/******/ 				return promises;
/******/ 			}, []));
/******/ 		};
/******/ 	})();
```

---

TITLE: Webpack Configuration
DESCRIPTION: This is the webpack configuration file used for the project. The critical part, not explicitly shown here but described in the surrounding text, is the use of `optimization.runtimeChunk` to create a separate runtime chunk.
SOURCE: https://github.com/webpack/webpack/blob/main/examples/chunkhash/template.md#_snippet_1

LANGUAGE: javascript
CODE:

```
_{{webpack.config.js}}_
```

---

TITLE: dist/output.js Webpack Output Bundle
DESCRIPTION: This is the main output bundle generated by Webpack. It contains the entry point module and any statically imported modules, along with the bundle loader wrapper.
SOURCE: https://github.com/webpack/webpack/blob/main/examples/code-splitting-bundle-loader/template.md#_snippet_2

LANGUAGE: JavaScript
CODE:

```
_{{dist/output.js}}_
```

---

TITLE: Importing and Logging Modules in JavaScript (page1.js)
DESCRIPTION: This JavaScript code imports `isomorphicFetch`, `react`, and `reactDOM` modules and logs them to the console. It also asynchronously imports `./lazy.js` using dynamic imports (`import("./lazy")`). The purpose is to include react related vendors in the page1 chunk and also lazy load `lazy.js` chunk.
SOURCE: https://github.com/webpack/webpack/blob/main/examples/code-splitting-depend-on-advanced/README.md#_snippet_2

LANGUAGE: javascript
CODE:

```
import isomorphicFetch from "isomorphic-fetch";
import react from "react";
import reactDOM from "react-dom";

console.log(isomorphicFetch, react, reactDOM);

import("./lazy");
```

---

TITLE: Importing and Displaying Images with Asset Modules - Javascript
DESCRIPTION: This JavaScript snippet imports PNG, JPG, and SVG images as modules and dynamically creates image elements to display them. It creates a container, appends image elements with titles and sets attributes using Javascript.
SOURCE: https://github.com/webpack/webpack/blob/main/examples/asset-simple/README.md#_snippet_0

LANGUAGE: javascript
CODE:

```
import png from "./images/file.png";
import jpg from "./images/file.jpg";
import svg from "./images/file.svg";

const container = document.createElement("div");
Object.assign(container.style, {
	display: "flex",
	justifyContent: "center"
});
document.body.appendChild(container);

function createImageElement(title, src) {
	const div = document.createElement("div");
	div.style.textAlign = "center";

	const h2 = document.createElement("h2");
	h2.textContent = title;
	div.appendChild(h2);

	const img = document.createElement("img");
	img.setAttribute("src", src);
	img.setAttribute("width", "150");
	div.appendChild(img);

	container.appendChild(div);
}

[png, jpg, svg].forEach(src => {
	createImageElement(src.split(".").pop(), src);
});
```

---

TITLE: Webpack Configuration (webpack.config.js)
DESCRIPTION: This file configures webpack to bundle the application, defining the entry point, output path, and optimization settings. The `splitChunks` option with `minSize: 0` ensures that even small common modules are split into separate chunks. The `chunkIds: "named"` configuration keeps the chunk filenames consistent across different build modes, improving caching and debugging.
SOURCE: https://github.com/webpack/webpack/blob/main/examples/common-chunk-grandchildren/README.md#_snippet_5

LANGUAGE: javascript
CODE:

```
"use strict";
const path = require("path");

module.exports = {
	// mode: "development" || "production",
	entry: {
		main: ["./example.js"]
	},
	optimization: {
		splitChunks: {
			minSize: 0 // This example is too small, in practice you can use the defaults
		},
		chunkIds: "named" // To keep filename consistent between different modes (for example building only)
	},
	output: {
		path: path.resolve(__dirname, "dist"),
		filename: "output.js"
	}
};
```

---

TITLE: Webpack Configuration with Module Federation (app)
DESCRIPTION: This webpack configuration defines the 'app' module. It configures the entry point, output, module rules (using babel-loader for React), optimization settings, and plugins. The ModuleFederationPlugin is used to define remote modules ('mfe-b' and 'mfe-c') and shared modules ('react'). The 'react' module is configured as a singleton to ensure only one instance is used.
SOURCE: https://github.com/webpack/webpack/blob/main/examples/module-federation/README.md#_snippet_0

LANGUAGE: javascript
CODE:

```
const path = require("path");
const { ModuleFederationPlugin } = require("../../").container;
const rules = [
	{
		test: /\.js$/,
		include: path.resolve(__dirname, "src"),
		use: {
			loader: "babel-loader",
			options: {
				presets: ["@babel/react"]
			}
		}
	}
];
const optimization = {
	chunkIds: "named", // for this example only: readable filenames in production too
	nodeEnv: "production" // for this example only: always production version of react
};
const stats = {
	chunks: true,
	modules: false,
	chunkModules: true,
	chunkOrigins: true
};
module.exports = (env = "development") => [
	// For this example we have 3 configs in a single file
	// In practice you probably would have separate config
	// maybe even separate repos for each build.
	// For Module Federation there is not compile-time dependency
	// between the builds.
	// Each one can have different config options.
	{
		name: "app",
		mode: env,
		entry: {
			app: "./src/index.js"
		},
		output: {
			filename: "[name].js",
			path: path.resolve(__dirname, "dist/aaa"),
			publicPath: "dist/aaa/",

			// Each build needs a unique name
			// to avoid runtime collisions
			// The default uses "name" from package.json
			uniqueName: "module-federation-aaa"
		},
		module: { rules },
		optimization,
		plugins: [
			new ModuleFederationPlugin({
				// List of remotes with URLs
				remotes: {
					"mfe-b": "mfeBBB@/dist/bbb/mfeBBB.js",
					"mfe-c": "mfeCCC@/dist/ccc/mfeCCC.js"
				},

				// list of shared modules with optional options
				shared: {
					// specifying a module request as shared module
					// will provide all used modules matching this name (version from package.json)
					// and consume shared modules in the version specified in dependencies from package.json
					// (or in dev/peer/optionalDependencies)
					// So it use the highest available version of this package matching the version requirement
					// from package.json, while providing it's own version to others.
					react: {
						singleton: true // make sure only a single react module is used
					}
				}
			})
		],
		stats
	}
```

---

TITLE: Configuring Webpack for Development and Production (JavaScript)
DESCRIPTION: This snippet configures webpack for different environments. It sets the mode, configures infrastructure logging, sets up file system caching, and defines a rule to handle CSS files. It uses `path` module to resolve file paths.
SOURCE: https://github.com/webpack/webpack/blob/main/examples/persistent-caching/README.md#_snippet_1

LANGUAGE: javascript
CODE:

```
const path = require("path");
module.exports = (env = "development") => ({
	mode: env,
	infrastructureLogging: {
		// Optional: print more verbose logging about caching
		level: "verbose"
	},
	cache: {
		type: "filesystem",

		// changing the cacheDirectory is optional,
		// by default it will be in `node_modules/.cache`
		cacheDirectory: path.resolve(__dirname, ".cache"),

		// Add additional dependencies to the build
		buildDependencies: {
			// recommended to invalidate cache on config changes
			// This also makes all dependencies of this file build dependencies
			config: [__filename]
			// By default webpack and loaders are build dependencies
		}
	},
	module: {
		rules: [
			{
				test: /\.css$/,
				use: ["style-loader", "css-loader"]
			}
		]
	}
});
```

---

TITLE: Configuring Webpack Entry Points with dependOn in JavaScript
DESCRIPTION: This webpack configuration defines multiple entry points (`app`, `page1`, `react-vendors`, `other-vendors`) and specifies dependencies between them using the `dependOn` option. It also configures the `optimization` and `stats` options. This setup demonstrates how to manage code splitting and shared dependencies in a Webpack project. The runtimeChunk is set to 'single', and chunkIds are 'named'.
SOURCE: https://github.com/webpack/webpack/blob/main/examples/code-splitting-depend-on-advanced/README.md#_snippet_0

LANGUAGE: javascript
CODE:

```
module.exports = {
	entry: {
		app: { import: "./app.js", dependOn: ["other-vendors"] },
		page1: { import: "./page1.js", dependOn: ["app", "react-vendors"] },
		"react-vendors": ["react", "react-dom", "prop-types"],
		"other-vendors": "./other-vendors"
	},
	optimization: {
		runtimeChunk: "single",
		chunkIds: "named" // To keep filename consistent between different modes (for example building only)
	},
	stats: {
		chunks: true,
		chunkRelations: true
	}
};
```

---

TITLE: Webpack Configuration Example
DESCRIPTION: This is the webpack configuration file that defines entry points, output settings, and the `dependOn` option for code splitting. It configures how the different JavaScript modules are bundled into separate files.
SOURCE: https://github.com/webpack/webpack/blob/main/examples/code-splitting-depend-on-advanced/template.md#_snippet_0

LANGUAGE: JavaScript
CODE:

```
_{{webpack.config.js}}_
```

---

TITLE: Webpack App Compilation Output
DESCRIPTION: This snippet shows the webpack compilation output for the 'app' module. It lists the generated assets, chunks, their sizes, and dependencies. It highlights the use of shared modules like 'react' and external modules like 'mfeBBB' and 'mfeCCC'.
SOURCE: https://github.com/webpack/webpack/blob/main/examples/module-federation/README.md#_snippet_14

LANGUAGE: JavaScript
CODE:

```
app:
  asset src_bootstrap_js.js 43.7 KiB [emitted]
  asset app.js 30.1 KiB [emitted] (name: app)
  asset vendors-node_modules_react_index_js.js 27.5 KiB [emitted] (id hint: vendors)
  chunk (runtime: app) app.js (app) 672 bytes (javascript) 42 bytes (share-init) 19 KiB (runtime) [entry] [rendered]
    > ./src/index.js app
    runtime modules 19 KiB 13 modules
    built modules 672 bytes (javascript) 42 bytes (share-init) [built]
      ./src/index.js 588 bytes [built] [code generated]
      external "mfeBBB@/dist/bbb/mfeBBB.js" 42 bytes [built] [code generated]
      external "mfeCCC@/dist/ccc/mfeCCC.js" 42 bytes [built] [code generated]
      provide shared module (default) react@19.1.0 = ../../node_modules/react/index.js 42 bytes [built] [code generated]
  chunk (runtime: app) src_bootstrap_js.js 26.3 KiB (javascript) 84 bytes (consume-shared) 12 bytes (remote) 12 bytes (share-init) [rendered]
    > ./bootstrap ./src/index.js 10:0-21
    dependent modules 25.9 KiB (javascript) 84 bytes (consume-shared) 12 bytes (remote) 12 bytes (share-init) [dependent] 17 modules
    ./src/bootstrap.js 380 bytes [built] [code generated]
  chunk (runtime: app) vendors-node_modules_react_index_js.js (id hint: vendors) 16.9 KiB [rendered] reused as split chunk (cache group: defaultVendors)
    > provide shared module (default) react@19.1.0 = ../../node_modules/react/index.js
    > consume shared module (default) react@^19.1.0 (singleton) (fallback: ../../node_modules/react/index.js)
    > consume shared module (default) react@^19.0.0 (singleton) (fallback: ../../node_modules/react/index.js)
    dependent modules 16.7 KiB [dependent] 1 module
    ../../node_modules/react/index.js 186 bytes [built] [code generated]
  chunk (runtime: app) 6 bytes (remote) 6 bytes (share-init)
    > mfe-c/Component2 ./src/App.js 7:49-75
    remote mfe-c/Component2 6 bytes (remote) 6 bytes (share-init) [built] [code generated]
  app (webpack 5.99.6) compiled successfully
```

---

TITLE: Webpack Configuration with Custom Parsers
DESCRIPTION: This webpack configuration (`webpack.config.js`) defines rules to parse TOML, JSON5, and YAML files as JSON modules. It uses the `toml`, `json5`, and `yamljs` libraries to parse these file types, respectively. The `type: "json"` setting ensures that webpack treats the parsed output as a JSON module.
SOURCE: https://github.com/webpack/webpack/blob/main/examples/custom-json-modules/README.md#_snippet_4

LANGUAGE: javascript
CODE:

```
const toml = require("toml");
const json5 = require("json5");
const yaml = require("yamljs");

module.exports = {
	module: {
		rules: [
			{
				test: /\.toml$/,
				type: "json",
				parser: {
					parse: toml.parse
				}
			},
			{
				test: /\.json5$/,
				type: "json",
				parser: {
					parse: json5.parse
				}
			},
			{
				test: /\.yaml$/,
				type: "json",
				parser: {
					parse: yaml.parse
				}
			}
		]
	}
};
```

---

TITLE: Webpack Module Cache and Require Function
DESCRIPTION: This snippet defines the Webpack module cache and the `__webpack_require__` function. The module cache stores already loaded modules, and the `__webpack_require__` function is used to retrieve modules from the cache or load them if they are not yet loaded. It also handles executing the module function.
SOURCE: https://github.com/webpack/webpack/blob/main/examples/chunkhash/README.md#_snippet_4

LANGUAGE: javascript
CODE:

```
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
```

---

TITLE: Loading Remote Modules Asynchronously with Promises (Webpack)
DESCRIPTION: This code asynchronously loads remote modules mfeBBB and mfeCCC using dynamic imports and Promises. It checks if the module is already defined. If not, it creates a script tag, appends it to the document, and resolves the Promise when the module is loaded. If the script fails to load, it rejects the Promise with an error message.
SOURCE: https://github.com/webpack/webpack/blob/main/examples/module-federation/README.md#_snippet_8

LANGUAGE: javascript
CODE:

```
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
var __webpack_error__ = new Error();
module.exports = new Promise((resolve, reject) => {
	if(typeof mfeBBB !== "undefined") return resolve();
	__webpack_require__.l("/dist/bbb/mfeBBB.js", (event) => {
		if(typeof mfeBBB !== "undefined") return resolve();
		var errorType = event && (event.type === 'load' ? 'missing' : event.type);
		var realSrc = event && event.target && event.target.src;
		__webpack_error__.message = 'Loading script failed.\n(' + errorType + ': ' + realSrc + ')';
		__webpack_error__.name = 'ScriptExternalLoadError';
		__webpack_error__.type = errorType;
		__webpack_error__.request = realSrc;
		reject(__webpack_error__);
	}, "mfeBBB");
}).then(() => (mfeBBB));

/***/ })
```

LANGUAGE: javascript
CODE:

```
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
var __webpack_error__ = new Error();
module.exports = new Promise((resolve, reject) => {
	if(typeof mfeCCC !== "undefined") return resolve();
	__webpack_require__.l("/dist/ccc/mfeCCC.js", (event) => {
		if(typeof mfeCCC !== "undefined") return resolve();
		var errorType = event && (event.type === 'load' ? 'missing' : event.type);
		var realSrc = event && event.target && event.target.src;
		__webpack_error__.message = 'Loading script failed.\n(' + errorType + ': ' + realSrc + ')';
		__webpack_error__.name = 'ScriptExternalLoadError';
		__webpack_error__.type = errorType;
		__webpack_error__.request = realSrc;
		reject(__webpack_error__);
	}, "mfeCCC");
}).then(() => (mfeCCC));

/***/ })
```

---

TITLE: Webpack Configuration for App with DLL
DESCRIPTION: This webpack configuration uses the DllReferencePlugin to reference a previously built vendor DLL. It reads the DLL's manifest and excludes vendor modules from the compilation, referencing them via a global variable. The entry point is './example-app.js' and the output is 'dist/app.js'.
SOURCE: https://github.com/webpack/webpack/blob/main/examples/dll-app-and-vendor/1-app/template.md#_snippet_0

LANGUAGE: javascript
CODE:

```
_{{webpack.config.js}}_
```

---

TITLE: Defining Entry Points and Commons Chunk - Webpack Configuration - JavaScript
DESCRIPTION: This snippet represents the webpack configuration file, defining multiple entry points for different pages (pageA, pageB). It also configures a 'commons' chunk to extract shared dependencies into a separate file, optimizing for browser caching and reducing bundle sizes. The entry property defines the entry points, and the optimization.splitChunks.cacheGroups configuration creates the commons chunk.
SOURCE: https://github.com/webpack/webpack/blob/main/examples/multiple-entry-points/template.md#_snippet_0

LANGUAGE: JavaScript
CODE:

```
_{{webpack.config.js}}_
```

---

TITLE: Webpack Configuration
DESCRIPTION: This Webpack configuration file defines entry points with 'dependOn' to share dependencies. It creates separate bundles for application code and React vendors, optimizing for code reuse and caching. It includes configurations for development and production environments.
SOURCE: https://github.com/webpack/webpack/blob/main/examples/code-splitting-depend-on-simple/template.md#_snippet_0

LANGUAGE: JavaScript
CODE:

```
_{{webpack.config.js}}_
```

---

TITLE: Webpack Load Script Function
DESCRIPTION: The `__webpack_require__.l` function dynamically loads JavaScript files using script tags. It handles caching, timeouts, and error handling. It injects script tags into the document head and manages the loading state to prevent duplicate requests. Uses `inProgress` object to keep track of loading scripts.
SOURCE: https://github.com/webpack/webpack/blob/main/examples/code-splitting-harmony/README.md#_snippet_9

LANGUAGE: javascript
CODE:

```
(() => {
		var inProgress = {};
		// data-webpack is not used as build has no uniqueName
		// loadScript function to load a script via script tag
		__webpack_require__.l = (url, done, key, chunkId) => {
			if(inProgress[url]) { inProgress[url].push(done); return; }
			var script, needAttach;
			if(key !== undefined) {
				var scripts = document.getElementsByTagName("script");
				for(var i = 0; i < scripts.length; i++) {
					var s = scripts[i];
					if(s.getAttribute("src") == url) { script = s; break; }
				}
			}
			if(!script) {
				needAttach = true;
				script = document.createElement('script');

				script.charset = 'utf-8';
				script.timeout = 120;
				if (__webpack_require__.nc) {
					script.setAttribute("nonce", __webpack_require__.nc);
				}


				script.src = url;
			}
			inProgress[url] = [done];
			var onScriptComplete = (prev, event) => {
				// avoid mem leaks in IE.
				script.onerror = script.onload = null;
				clearTimeout(timeout);
				var doneFns = inProgress[url];
				delete inProgress[url];
				script.parentNode && script.parentNode.removeChild(script);
				doneFns && doneFns.forEach((fn) => (fn(event)));
				if(prev) return prev(event);
			}
			var timeout = setTimeout(onScriptComplete.bind(null, undefined, { type: 'timeout', target: script }), 120000);
			script.onerror = onScriptComplete.bind(null, script.onerror);
			script.onload = onScriptComplete.bind(null, script.onload);
			needAttach && document.head.appendChild(script);
		};
	})()
```

---

TITLE: Webpack Build Output (Production)
DESCRIPTION: This snippet presents the standard output from executing webpack in production mode. It displays details about the built bundles including sizes, optimization metrics, and any related warnings or errors. This build should be optimized for deployment.
SOURCE: https://github.com/webpack/webpack/blob/main/examples/module-federation/template.md#_snippet_10

LANGUAGE: text
CODE:

```
_{{production:stdout}}_
```

---

TITLE: Exposed React Component (mfe-b)
DESCRIPTION: This is a React component exposed by the 'mfe-b' module. It uses the 'date-fns' library, which is a shared module. It formats a date using the provided locale and displays it within the component. This component serves as an example of how to expose components and use shared modules within a federated module.
SOURCE: https://github.com/webpack/webpack/blob/main/examples/module-federation/README.md#_snippet_7

LANGUAGE: javascript
CODE:

```
import React from "react";
import { formatRelative, subDays } from "date-fns";
// date-fns is a shared module, but used as usual
// exposing modules act as async boundary,
// so no additional async boundary need to be added here
// As data-fns is an shared module, it will be placed in a separate file
// It will be loaded in parallel to the code of this module

const Component = ({ locale }) => (
	<div style={{ border: "5px solid darkblue" }}>
		<p>I'm a Component exposed from container B!</p>
		<p>
			Using date-fn in Remote:{" "}
			{formatRelative(subDays(new Date(), 2), new Date(), { locale })}
		</p>
	</div>
);
export default Component;
```

---

TITLE: Dynamic Import with `import()` (JavaScript)
DESCRIPTION: This code snippet demonstrates how to use dynamic imports (`import()`) to load a module asynchronously. It defines two functions: `CreateUserAction` and `AlternativeCreateUserAction`. `CreateUserAction` loads the `UserApi` module and calls its `createUser` function. `AlternativeCreateUserAction` uses `import()` inside the async function to achieve lazy loading.
SOURCE: https://github.com/webpack/webpack/blob/main/examples/top-level-await/README.md#_snippet_2

LANGUAGE: javascript
CODE:

```
// import() doesn't care about whether a module is an async module or not
const UserApi = import("./UserApi.js");

export const CreateUserAction = async name => {
	// These are normal awaits, because they are in an async function
	const { createUser } = await UserApi;
	await createUser(name);
};

// You can place import() where you like
// Placing it at top-level will start loading and evaluating on
//   module evaluation.
//   see CreateUserAction above
//   Here: Connecting to the DB starts when the application starts
// Placing it inside of an (async) function will start loading
//   and evaluating when the function is called for the first time
//   which basically makes it lazy-loaded.
//   see AlternativeCreateUserAction below
//   Here: Connecting to the DB starts when AlternativeCreateUserAction
//         is called
export const AlternativeCreateUserAction = async name => {
	const { createUser } = await import("./UserApi.js");
	await createUser(name);
};
```

---

TITLE: Webpack Module System Implementation
DESCRIPTION: This snippet defines the core of the Webpack module system, including the `__webpack_require__` function for resolving module dependencies and the module cache. It handles module caching, execution, and export management. It utilizes the `__webpack_module_cache__` to store cached modules and the `__webpack_modules__` array to access module definitions.
SOURCE: https://github.com/webpack/webpack/blob/main/examples/code-splitting-native-import-context/README.md#_snippet_3

LANGUAGE: javascript
CODE:

```
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
```

---

TITLE: Filtering Dynamic Imports with webpackInclude/Exclude (JavaScript)
DESCRIPTION: This code snippet demonstrates how to use webpack's dynamic `import()` function along with `webpackInclude` and `webpackExclude` magic comments. The `webpackInclude` comment specifies a regular expression that matches files to include, and the `webpackExclude` comment specifies a regular expression that matches files to exclude. It imports modules from the `./templates/` directory dynamically based on filename and logs or returns an error.
SOURCE: https://github.com/webpack/webpack/blob/main/examples/code-splitting-native-import-context-filter/README.md#_snippet_0

LANGUAGE: javascript
CODE:

```
async function getTemplate(templateName) {
	try {
		let template = await import(
			/* webpackInclude: /\.js$/ */
			/* webpackExclude: /\.noimport\.js$/ */
			`./templates/${templateName}`
		);
		console.log(template);
	} catch(err) {
		console.error(err);
		return new Error(err);
	}
}

getTemplate("foo");
getTemplate("bar");
getTemplate("baz");
getTemplate("foo.noimport");
getTemplate("bar.noimport");
getTemplate("baz.noimport");
```

---

TITLE: Bundled Other Vendors JavaScript
DESCRIPTION: This is the bundled JavaScript code for other vendors library, generated by webpack. This output is used for other vendor dependencies.
SOURCE: https://github.com/webpack/webpack/blob/main/examples/code-splitting-depend-on-advanced/template.md#_snippet_8

LANGUAGE: JavaScript
CODE:

```
_{{dist/other-vendors.js}}_
```

---

TITLE: Production Mode Webpack Build Output
DESCRIPTION: This snippet presents the output of the webpack build process in production mode. Production mode typically enables optimizations like minification, tree shaking, and dead code elimination to reduce the bundle size and improve performance. The standard output often contains information about the build time, file sizes, and any warnings or errors.
SOURCE: https://github.com/webpack/webpack/blob/main/examples/harmony-library/template.md#_snippet_3

LANGUAGE: text
CODE:

```
_{{production:stdout}}_
```

---

TITLE: HTML Bootstrap File
DESCRIPTION: This HTML file serves as the entry point for the application. It includes styling for a loading spinner and script tags to load the main application ('app.js') and the remote modules ('mfeBBB.js' and 'mfeCCC.js'). The script tags are set to 'async' to improve loading performance. It explains that inlining the scripts may be optimal for performance.
SOURCE: https://github.com/webpack/webpack/blob/main/examples/module-federation/README.md#_snippet_6

LANGUAGE: html
CODE:

```
<html>
	<head>
		<style>
			.spinner {
				font-size: 10px;
				margin: 50px auto;
				text-indent: -9999em;
				width: 11em;
				height: 11em;
				border-radius: 50%;
				background: #595959;
				background: linear-gradient(
					to right,
					#595959 10%,
					rgba(89, 89, 89, 0) 42%
				);
				position: relative;
				animation: spin 1.4s infinite linear;
				transform: translateZ(0);
			}
			.spinner:before {
				width: 50%;
				height: 50%;
				background: #595959;
				border-radius: 100% 0 0 0;
				position: absolute;
				top: 0;
				left: 0;
				content: "";
			}
			.spinner:after {
				background: white;
				width: 75%;
				height: 75%;
				border-radius: 50%;
				content: "";
				margin: auto;
				position: absolute;
				top: 0;
				left: 0;
				bottom: 0;
				right: 0;
			}
			@-webkit-keyframes spin {
				0% {
					-webkit-transform: rotate(0deg);
					transform: rotate(0deg);
				}
				100% {
					-webkit-transform: rotate(360deg);
					transform: rotate(360deg);
				}
			}
			@keyframes spin {
				0% {
					-webkit-transform: rotate(0deg);
					transform: rotate(0deg);
				}
				100% {
					-webkit-transform: rotate(360deg);
					transform: rotate(360deg);
				}
			}
		</style>
	</head>
	<body>
		<!-- A spinner -->
		<div class="spinner"></div>

		<!-- This script only contains bootstrapping logic -->
		<!-- It will load all other scripts if necessary -->
		<script src="/dist/aaa/app.js" async></script>

		<!-- These script tags are optional -->
		<!-- They improve loading performance -->
		<!-- Omitting them will add an additional round trip -->
		<script src="/dist/bbb/mfeBBB.js" async></script>
		<script src="/dist/ccc/mfeCCC.js" async></script>

		<!-- All these scripts are pretty small ~5kb -->
		<!-- For optimal performance they can be inlined -->
	</body>
</html>
```

---

TITLE: Webpack Vendor Configuration
DESCRIPTION: This Webpack configuration file defines how to build the vendor DLL. It specifies the entry point, output filename, output path, library name, and the DllPlugin configuration. The DllPlugin generates a manifest file containing module mappings.
SOURCE: https://github.com/webpack/webpack/blob/main/examples/dll-app-and-vendor/0-vendor/README.md#_snippet_0

LANGUAGE: javascript
CODE:

```
var path = require("path");
var webpack = require("../../../");

module.exports = {
	// mode: "development" || "production",
	context: __dirname,
	entry: ["example-vendor"],
	output: {
		filename: "vendor.js", // best use [fullhash] here too
		path: path.resolve(__dirname, "dist"),
		library: "vendor_lib_[fullhash]"
	},
	plugins: [
		new webpack.DllPlugin({
			name: "vendor_lib_[fullhash]",
			path: path.resolve(__dirname, "dist/vendor-manifest.json")
		})
	]
};
```

---

TITLE: Main React App Component
DESCRIPTION: This is the main React component of the 'app' module. It imports components from remote modules ('mfe-b/Component' and 'mfe-c/Component') and uses them within its render method. It also demonstrates lazy loading of a remote component ('mfe-c/Component2') using React.Suspense. It imports `de` locale from `date-fns`.
SOURCE: https://github.com/webpack/webpack/blob/main/examples/module-federation/README.md#_snippet_5

LANGUAGE: javascript
CODE:

```
import React from "react";
import ComponentB from "mfe-b/Component"; // <- these are remote modules,
import ComponentC from "mfe-c/Component"; // <- but they are used as usual packages
import { de } from "date-fns/locale";

// remote modules can also be used with import() which lazy loads them as usual
const ComponentD = React.lazy(() => import("mfe-c/Component2"));

const App = () => (
	<article>
		<header>
			<h1>Hello World</h1>
		</header>
		<p>This component is from a remote container:</p>
		<ComponentB locale={de} />
		<p>And this component is from another remote container:</p>
		<ComponentC locale={de} />
		<React.Suspense fallback={<p>Lazy loading component...</p>}>
			<p>
				And this component is from this remote container too, but lazy loaded:
			</p>
			<ComponentD />
		</React.Suspense>
	</article>
);
export default App;
```

---

TITLE: Application Entry Point
DESCRIPTION: This is the main entry point for the 'app' module. It uses a dynamic import to load the 'bootstrap' module. This ensures that shared modules are initialized and remote modules are loaded before the main application logic is executed. The comment indicates that any code placed directly in index.js before the import cannot use shared or remote modules.
SOURCE: https://github.com/webpack/webpack/blob/main/examples/module-federation/README.md#_snippet_3

LANGUAGE: javascript
CODE:

```
// Sharing modules requires that all remotes are initialized
// and can provide shared modules to the common scope
// As this is an async operation we need an async boundary (import())

// Using modules from remotes is also an async operation
// as chunks need to be loaded for the code of the remote module
// This also requires an async boundary (import())

// At this point shared modules initialized and remote modules are loaded
import("./bootstrap");

// It's possible to place more code here to do stuff on page init
// but it can't use any of the shared modules or remote modules.
```

---

TITLE: Runtime Chunk Output
DESCRIPTION: This is the output of the runtime chunk, named `runtime~main.[chunkhash].js`. Its content isn't provided in the context but it contains the webpack runtime and chunkhash mappings.
SOURCE: https://github.com/webpack/webpack/blob/main/examples/chunkhash/template.md#_snippet_3

LANGUAGE: javascript
CODE:

```
_{{dist/runtime~main.chunkhash.js}}_
```

---

TITLE: Webpack Configuration in Javascript
DESCRIPTION: This code defines the Webpack configuration, enabling optimizations such as 'usedExports' and 'concatenateModules'. 'concatenateModules' enables scope hoisting to reduce the size of the output bundle. 'chunkIds' are set to named for consistent filenames.
SOURCE: https://github.com/webpack/webpack/blob/main/examples/scope-hoisting/README.md#_snippet_9

LANGUAGE: javascript
CODE:

```
module.exports = {
	// mode: "development" || "production",
	optimization: {
		usedExports: true,
		concatenateModules: true,
		chunkIds: "named" // To keep filename consistent between different modes (for example building only)
	}
};
```

---

TITLE: Code Splitting with require.ensure in JavaScript
DESCRIPTION: This JavaScript code demonstrates code splitting using webpack's `require.ensure` function. It requires modules `a` and `b` normally. Module `c` is loaded on demand via `require.ensure`. Inside the callback, module `b` is accessed and module `d` is also required, triggering on-demand loading for both. This example shows how webpack handles dependencies and creates separate chunks for lazy loading.
SOURCE: https://github.com/webpack/webpack/blob/main/examples/code-splitting/README.md#_snippet_0

LANGUAGE: JavaScript
CODE:

```
var a = require("a");
var b = require("b");
require.ensure(["c"], function(require) {
    require("b").xyz();
    var d = require("d");
});
```
